\documentclass{article}
\usepackage{imakeidx}
\usepackage{multirow}
\usepackage[a4paper,top=2cm,bottom=2.5cm,left=1.5cm,right=1.5cm,marginparwidth=1.75cm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{caption}
\usepackage{geometry}
\usepackage{datetime}
\usepackage{wrapfig}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{hyphenat}
\usepackage[export]{adjustbox}
\usepackage[colorlinks=true, allcolors=black]{hyperref}
\usepackage{comment}
\usepackage{blindtext}
\usepackage{graphicx}
\usepackage{float}
\usepackage{tablefootnote}
\usepackage[bottom]{footmisc}
\usepackage[table,xcdraw]{xcolor}
\usepackage{subfig}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}

\begin{document}
\begin{center}
    \begin{minipage}{0.83\linewidth}
        \centering
        \includegraphics[width=0.4\textwidth]{Images/UM.jpg}\par\vspace{0.5cm}
        {\scshape\textbf{Universidade do Minho}} \par
        {\scshape Licenciatura em Engenharia Informática} \par
        \vspace{3cm}
        {\LARGE Fase 1\\} \par
        {\scshape\LARGE \textbf{Projeto LI3}\\} \par
        \vspace{1.0cm}
        {\LARGE \textbf{Airline Manager}} \par
        \vspace{2cm}
        {\LARGE\textbf {PL6 - Grupo 27}} \par
        \vspace{0.1cm}
        {\LARGE Hugo Abelheira(a95151)\par Luís França(a104259)\par Mariana Rocha(a90817) \par}
        
        \vspace{5cm}
        {\large \today\par}
        
    \end{minipage}
\end{center}
\newpage
\tableofcontents
\listoftables
\listoffigures

\newpage
\section{Introdução}
\paragraph{}O projeto em desenvolvimento no âmbito da disciplina de Laboratórios de Informática 3 tem como objetivo principal realizar o tratamento de dados provenientes de extensos conjuntos de informações contidas em arquivos CSV. Este tratamento envolve a implementação de um processo de parsing, onde os dados são interpretados e transformados em entidades representativas, que por sua vez são armazenadas em estruturas de dados específicas denominadas catálogos.
\vspace{-0.75cm} %idk why but needed more space
\paragraph{}Além do \textit{parsing}, uma etapa crítica do projeto envolve a validação de campos, garantindo a integridade e consistência dos dados processados.
\vspace{-0.3cm}
\paragraph{}Os catálogos criados não apenas armazenam os dados de maneira eficiente, mas também servem como base para a execução de \textit{queries} (consultas). Utilizando diversas estruturas de dados adicionais, o projeto propõe a implementação de \textit{queries} que fornecem informações específicas a partir dos dados armazenados nos catálogos. Estas são formuladas com base em requisitos pré-definidos e, quando executadas, geram resultados que são posteriormente processados e apresentados no respetivo formato.
\vspace{-0.3cm}  
\paragraph{}A complexidade do projeto é ampliada pelo facto de nos ser fornecido um ficheiro de \textit{input}, onde cada linha contém um comando que corresponde ao tipo da \textit{query} e os argumentos associados. A execução desses comandos requer uma lógica adaptativa, garantindo que cada \textit{query} seja processada corretamente e que os resultados sejam armazenados nos respetivos ficheiros de \textit{output}.
\vspace{-0.3cm}
\paragraph{}Dessa forma, este projeto abrange uma variedade de conceitos essenciais, funcionando também como uma ponte de aprendizagem para programação orientada a objetos, desde manipulação de arquivos e \textit{parsing} de dados até a manipulação de estruturas de dados complexas e a execução dinâmica de consultas. O desafio reside não apenas na correta implementação desses aspetos individuais, mas também na integração eficiente e eficaz de todos os elementos para criar um sistema coeso e funcional.

\section{Arquitetura do Projeto}
\paragraph{}Ao conceber a arquitetura deste projeto, adotamos uma abordagem modular para garantir uma implementação robusta e escalável. O sistema é composto por vários módulos relacionados entre si, cada um responsável por tarefas diferentes, mas resumidamente dividos em 3 componentes essenciais: \textbf{Processamento de Entrada}, \textbf{Lógica de Negócios} e \textbf{Geração de Resultados}.

\subsection{Processamento de Entrada}
\paragraph{}Os módulo encarregues pelo Processamento de Entrada são responsáveis pela ingestão de dados brutos provenientes de arquivos CSV. Nesta fase, os dados são submetidos a um processo de \textit{parsing}, onde são extraídas informações relevantes e validadas quanto à integridade dos campos. Durante esse processo, as entidades são construídas e os dados são transformados para serem armazenados nos catálogos correspondentes. Há ainda um módulo extra nesta componente inicial chamado \textit{interpreter} que tem a mesma função que o \textit{parser} mas para o ficheiro de \textit{input}, que contém um comando por linha, onde cada comando corresponde à execução de uma \textit{query}.

\subsection{Lógica de Negócios}
\paragraph{}A Lógica de Negócios representa o núcleo do sistema, onde os catálogos são continuamente alimentados e atualizados. Utilizamos a biblioteca \textit{GLib} para criar estruturas de dados dinâmicas que se ajustam às necessidades variáveis do projeto. A validação contínua dos dados durante o processo de \textit{parsing} assegura a coerência dos catálogos. 
Num módulo \textit{interpreter} identificamos o tipo de \textit{query} que queremos executar e, utilizando as informações contidas nos catálogos (gerenciadas por um \textit{catalog manager}, que corresponde à operação lógica de junção de todos os outros catálogos), um outro módulo \textit{queries} resolve a \textit{query} em questão, produzindo os resultados correspondentes para a escrita do \textit{output} correspondente.

\subsection{Geração de Saída}
\paragraph{}O módulo de Geração de Saída chamado \textit{output}, é responsável por criar os resultados das \textit{queries} em ficheiros de texto. Durante a execução das \textit{queries}, os resultados são formatados como pedido e armazenados de maneira eficiente nos arquivos de saída, preservando a estrutura e integridade dos dados. Esta fase utiliza as estruturas de dados previamente construídas nos catálogos.

\subsection{Representação Visual}
\paragraph{}A Figura 1 apresenta um diagrama simplificado que ilustra as principais classes e suas interações no sistema. Este diagrama proporciona uma visão visual clara da estrutura do projeto.
\begin{figure}[H]
\begin{center}
	\includegraphics[width=10cm]{Images/arquitetura.png} 
        \caption{Representação da Arquitetura do Projeto}
\end{center}
\end{figure}

\subsection{Considerações de Desempenho e Escalabilidade}
\paragraph{}A arquitetura foi projetada com ênfase na eficiência do processamento, minimizando a complexidade temporal e espacial. Utilizamos estruturas de dados dinâmicas, fornecidas pela biblioteca \textit{GLib}, o que garante escalabilidade e permite a gestão eficaz de grandes conjuntos de dados. 

\subsection{Padrões e Tecnologias Utilizados}
\paragraph{}Optamos por adotar uma abordagem modular na organização do código-fonte, dando prioridade à criação de módulos específicos à medida que identificamos conjuntos de funções com complexidade suficiente para justificar um novo módulo. Essa abordagem favorece a clareza e a manutenção do código, permitindo que cada módulo tenha responsabilidades bem definidas e uma interface coesa.

\subsection{Configuração e Compilação}
O \textit{Makefile} desempenha um papel crucial na organização e automatização do processo de compilação do nosso projeto. Este arquivo de configuração não só simplifica a construção do código-fonte, mas também facilita a manutenção e distribuição do projeto.
Alguns aspetos importantes a considerar sobre o nosso \textit{Makefile} são:
\begin{itemize}
\vspace{-0.2cm}
\item As flags de compilação incluem opções específicas para a biblioteca GLib, garantindo a compatibilidade e correta ligação durante o processo de compilação.
\item O Makefile suporta dois modos distintos de compilação: Debug e Release.
\item A estrutura do projeto é mantida através da criação de diretórios conforme necessário durante o processo de compilação.
\item Integrado ao Makefile, temos suporte para a geração automática de documentação usando o Doxygen.
\item O Makefile inclui uma regra "clean" para remover todos os objetos e ficheiros gerados durante o processo de compilação.
\end{itemize}

\subsection{Conclusão}
\paragraph{}A arquitetura proposta fornece uma base sólida para a implementação do projeto, garantindo a modularidade, a eficiência e a facilidade de manutenção. A interconexão fluida entre os módulos permite que o sistema atenda de forma eficaz aos requisitos funcionais, ao mesmo tempo que mantém a flexibilidade necessária para futuras expansões e melhorias.

%Utils: Módulo que contendo funções que nos vão auxiliar ao longo do programa.
%Parser: Módulo responsável por realizar o parsing dos ficheiros csv. 
%\paragraph{}Catalogs (Manager, Flights\_c, Reservations\_c, Users\_c, %Passengers\_c): Módulos responsáveis por criar as estruturas de dados que %ligam as várias entidades (Hash tables). O catálogo manager equivale à %junção de todos os outros catálogos. Também contém os getters e setter %dessas estruturas de dados.
%\paragraph{}Statistics: Módulo contendo estruturas de dados com informações %relevantes à execução de determinadas queries. 
%\paragraph{}Input: Módulo responsável por realizar a validação dos %ficheiros. 
%\paragraph{}Query: Módulo responsável pelo parser das querys, as querys em %si e outras funções relevantes à sua execução., tal como funções que %libertam memória alocada pelas queries. 
%\paragraph{}Output: Módulo responsável por criar e escrever os ficheiros de %output para cada query, verificando a presença da flag ‘F’ nas queries. 
%\paragraph{}Entities (Flights, Reservations, Users, Passengers):  Módulos %responsáveis por criar as estruturas de dados correspondente às entidades %individuais de cada tipo de ficheiro csv. Também contém os getters e 
%setters dessas estruturas de dados. 
%\paragraph{}Batch: Módulo responsável pelo modo de operação batch do %programa. 

\section{Desenvolvimento e Ideias Iniciais}
\paragraph{}Após termos a arquitetura do projeto definida, preocupámo-nos então com o desenvolvimento do código do projeto. 
\paragraph{}Começamos inicialmente por realizar um parser para os documentos csv, capaz de formatá-los dividindo cada linha do ficheiro em vários campos, sendo fácil assim manipulá-los para validação e organização nos catálogos. O parser seria capaz de receber um ficheiro csv, formatá-lo e passá-lo para uma função, recebida como argumento responsável por transformar a linha formatada numa entidade e validar essa mesma linha, escrevendo os erros na validação no ficheiro criado a esse destino.   
\paragraph{}A validação dos ficheiros foi realizada tendo em conta os requisitos descritos no enunciado do projeto, traduzindo esses requisitos para código, em diversas funções. Uma parte trabalhosa na validação foi interagir com os valores das datas, pois era necessário de validar bastantes valores, o ano, o mês e o dia, e adicionalmente no caso do formato apresentar hora, as horas, os minutos e os segundos, tudo isto recebido em formato string. 
\paragraph{}Em seguida criamos o módulo ‘batch’, responsável por criar encaminhar os argumentos que as funções de parsing precisavam além de chamar mais qualquer outra função que o programa precisa-se. Este módulo serviria então como a unidade central do modo de operação batch.  
\paragraph{}Agora que tinhamos um caminho para transmitir e fazer parsing dos ficheiros csv tinhamos que criar estruturas de dados próprias para guardar as informações que eles contêm - uma espécia de base de dados.  Para isso criamos catálogos um para cada tipo de ficheiro (passageiros, voos, utilizadores e reservas), estes catálogos era constituídos por hash tables que recebiam um identificador como chave e devolviam a estrutura de dados da entidade correspondente, facilitando qualquer acesso aos dados que queiramos fazer. 
\paragraph{}De seguida fomos para a criação de um sistema de execução de queries, começando por fazer, linha a linha, parsing das mesmas e depois executá-las dependendo do seu query\_id. Cada uma devolveria um resultado que seria escrito num ficheiro próprio de output, a formatação deste resultado dependeria na presença de uma flag ‘F’ junto ao identificador da query que faria com que o resultado tenho o formato field: value. 
\paragraph{}Para a primeira fase do projeto decidimos realizar as primeiras 6 queries, pois determinamos que seriam as mais fáceis de se concluir dentro do prazo previsto. 

$Comecamos por fazer o parsing dos ficheiros;
Depois optamos por validar todos os ficheiros;
De seguida criamos as entidades para representar a informação analisada;
Depois criamos a primeira versao dos nossos catalogos para armazenar as entidades com toda a informação guardada e processada;
Através dos catalogos desenvolvemos as \textit{queries} (consultas), para isto foi necessario fazer algumas alteracoes nos catalogos bem como adicionar outras estruturas de dados; 
Para finalizar esta fase tivemos apenas que definir um modulo para imprimir os resultados das \textit{queries} da forma pretendida, um ficheiro de output para cada linha do ficheiro input, correspondente a um comando, como visto anteriormente.$

\section{Soluções e Resolução de problemas}
Parsing: Fizemos um parsing simples, mas se calhar vale a pena mencionar alguma alteracao que possamos ter feito em ordem de corrigir algo ou por algo a funcionar.
Validação do dataset e Criacao de entidades: tivemos que ter em atenção as copias por causa do encapsulamento, a alocação de memoria por causa de memory leaks e da construção de uma entidade de forma aproprieada para termos o comportamento desejado.
Catalogos: Esta foi a parte mais desafiante do trabalho, conseguir inserir a informacao de forma correta e sem memory leaks, muitos problemas inesperados e algumas otimas (e outras nao tao otimas) solucoes!
Queries: Esta parte foi mais dificil do que o antecipado mas grande parte dos problemas advinham dos catalogos ou do comportamento inesperado de algumas estruturas de dados e diversas funções da glib. 
Output: Depois de arranjar a solução de usar o array result foi bastante facil desenvolver os ficheiros de output. 

\subsection{Valgrind & Debugger (GDB)}
Ferramentas usadas para localizar erros de memoria, bem como perceber se o programa esta a ter o comportamento esperado, analisando o estado do mesmo em várias alturas, executando linha a linha e recorrendo a breakpoints. Acesso a back trace stack (nao me lembro se é este o nome) que nos possibilitou encontrar o local do problema no nosso codigo.

\section{Resultados Finais}
\paragraph{}\textit{Query 1}: “Listar o resumo de um utilizador, voo, ou reserva, consoante o identificador recebido por argumento.”
A função \textit{query1} foi criada para extrair informações com base em um ID de entidade, que pode representar um voo, uma reserva ou um usuário, dependendo das condições de identificação. Ao receber um \textit{ID} como argumento, a função verifica se corresponde a um voo, reserva ou usuário, utilizando funções de obtenção específicas. Se a correspondência for encontrada, a função coleta informações pertinentes, como detalhes do voo, reserva ou usuário, e retorna um \textit{array} de strings dinamicamente alocado contendo esses dados. Além disso, a função faz a gestão adequada da memória, liberando-a quando necessário, e trata casos especiais, como usuários inativos, retornando NULL nesses cenários
\paragraph{}\textit{Query 2}: “Listar os voos ou reservas de um utilizador, se o segundo argumento for \textit{flights} ou \textit{reservations}, respetivamente, ordenados por data (da mais recente para a mais antiga). Caso não seja fornecido um segundo argumento, apresentar voos e reservas, juntamente com o tipo (\textit{flight} ou \textit{reservation}).”
A função \textit{query2} parece ser projetada para extrair informações relacionadas a voos e reservas associados a um usuário, permitindo a filtragem por tipo (todos, voos ou reservas) e a ordenação por data e identificador. A função utiliza estruturas de dados, como \textit{ResultEntry}, para representar informações de resultados, e implementa funções de comparação para ordenação. Ela manipula dinamicamente \textit{arrays} de \textit{IDs}, datas e tipos, iterando sobre voos e reservas associados ao usuário. Além disso, a função gerencia adequadamente a memória e retorna um array de strings formatado com informações ordenadas e específicas para cada tipo.
\paragraph{}\textit{Query 3}: “Apresentar a classificação média de um hotel, a partir do seu identificador.”
A função \textit{query3} parece ser destinada a calcular e retornar a média das avaliações (\textit{ratings}) para reservas associadas a um determinado hotel, identificado pelo \textit{ID} fornecido como argumento. A função itera sobre as reservas no catálogo, verifica se cada reserva pertence ao hotel desejado e, se for o caso, acumula as avaliações para posterior cálculo da média. A função usa a estrutura  \textit{RESERV\_C} para aceder e manipular as informações necessárias. A média resultante é convertida para uma string antes de ser devolvida.
\paragraph{}\textit{Query 4}: “Listar as reservas de um hotel, ordenadas por data de início (da mais recente para a mais antiga). Caso duas reservas tenham a mesma data, deve ser usado o identificador da reserva com o critério de desempate (de forma crescente).”A função \textit{query4}  destina-se a extrair e organizar informações sobre reservas associadas a um hotel específico, identificado pelo \textit{ID} fornecido como argumento. A função utiliza  a estrutura para representar informações de reservas, e implementa funções de comparação para ordenação com base em datas e \textit{IDs}. A função itera sobre as reservas no catálogo, verifica se cada reserva pertence ao hotel desejado e, se for o caso, armazena as informações relevantes em \textit{arrays}. Em seguida, ela utiliza uma função de ordenação para organizar essas informações e cria um \textit{array} de strings formatadas com os detalhes das reservas ordenadas.
\paragraph{}\textit{Query 5}: “Listar os voos com origem num dado aeroporto, entre duas datas, ordenados por data de partida estimada (da mais antiga para a mais recente). Caso dois voos tenham a mesma data, o identificador do voo deverá ser usado como critério de desempate (de forma crescente).“
A função \textit{query5} destina-se a organizar informações sobre voos com base na origem, na data de início e na data de fim fornecidas como argumentos. Ela utiliza a estrutura \textit{FlightInfo} para representar informações de voos e implementa funções de comparação para ordenação com base em datas e \textit{IDs}. A função itera sobre os voos no catálogo, verifica se cada voo atende aos critérios de origem e datas especificados, armazena as informações relevantes em \textit{arrays} e, em seguida, utiliza uma função de ordenação para organizar essas informações. O resultado final é um \textit{array} de strings formatadas com os detalhes dos voos ordenados.
\paragraph{}\textit{Query 6}: “Listar o top N aeroportos com mais passageiros, para um dado ano. Deverão ser contabilizados os voos com a data estimada de partida nesse ano. Caso dois aeroportos tenham o mesmo valor, deverá ser usado o nome do aeroporto como critério de desempate (de forma crescente).”
A função \textit{query6} processa informações sobre o número de passageiros em aeroportos durante um determinado ano. Utilizando estruturas de dados adequadas, ela itera sobre os voos do catálogo, identifica os aeroportos associados a esses voos e calcula o total de passageiros para cada aeroporto. Os resultados são ordenados em ordem decrescente com base no número de passageiros. A função retorna um \textit{array} de \textit{strings} contendo o nome do aeroporto e o número total de passageiros para os N aeroportos mais movimentados no ano especificado.
\paragraph{}Um ponto importante a ter atenção foi, no final, verificar que tinhamos libertado todo espaço alocado na memória ao longo do programa, incluindo criar funções com o propósito de fazer \textit{free} dos resultados das \textit{queries}. O descuidado com este detalhe leva a \textit{memory leaks}, problema que tivemos que lidar com alguma frequência ao longo do desenvolvimento deste programa. 
\section{Conclusão}
\paragraph{}Concluir este projeto representou uma jornada desafiadora, mas extremamente enriquecedora, que se traduziu numa notável evolução das nossas competências em engenharia informática. Durante o processo de desenvolvimento, concentramo-nos intensamente na manipulação avançada de estruturas de dados e na otimização das operações de leitura e escrita de ficheiros. Esta abordagem estratégica não apenas fortaleceu o nosso domínio técnico, mas também estabeleceu uma base sólida para as exigências futuras.
\paragraph{}Destacamos, desde cedo, a importância do encapsulamento do programa, antecipando as necessidades subsequentes. Essa decisão não reflete apenas a consistência do nosso processo de desenvolvimento, mas também minimiza a necessidade de reestruturações significativas no futuro. Tanto o código quanto a \textit{makefile}, na sua configuração atual, demonstram robustez, proporcionando uma plataforma eficiente para serem reaproveitados na próxima etapa.
\paragraph{}Embora estejamos confiantes na qualidade do nosso trabalho até agora, reconhecemos a necessidade de alguns ajustes para integrar de forma eficaz o modo \textit{interactive}, um requisito crucial na próxima fase do projeto. Esta reflexão crítica sobre o estado atual do código revela o nosso compromisso contínuo com a excelência e a adaptabilidade, garantindo que estamos preparados para enfrentar os desafios que se seguem com confiança e competência técnica.
\end{document}
